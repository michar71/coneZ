bas2wasm — BASIC to WASM Compiler
===================================

bas2wasm compiles ConeZ BASIC scripts (.bas) into WASM 1.0 binaries (.wasm)
that run on the ConeZ WASM runtime. The compiled output uses the same host
API as hand-written WASM modules (see wasm-api.txt).

The compiler is a single C file with no dependencies beyond libc. It can be
built on any system with a C compiler:

    cc -o bas2wasm tools/bas2wasm/bas2wasm.c
    ./bas2wasm script.bas -o script.wasm

The .wasm file can then be uploaded to the ConeZ filesystem and run with:

    run /script.wasm


Differences from the BASIC Interpreter
---------------------------------------

The compiler accepts the same language as the interpreter (see
basic-scripting.txt) with the following differences:

  Additions:
    - Floating-point variables and arithmetic (f32)
    - Float math functions: SIN, COS, SQRT, ATAN2, POW, TAN, EXP,
      LOG, LOG2, FLOOR, CEIL, FMOD, SGN
    - Type conversion functions: INT, FLOAT
    - Float-returning sensor functions with # suffix
    - FORMAT & placeholder for printing floats
    - CONST declarations
    - NOT (unary) and XOR (binary) operators
    - FOR STEP support
    - SELECT CASE (with multi-value, IS comparisons, ELSE)
    - DO...LOOP (all 5 variants: infinite, pre/post WHILE/UNTIL)
    - EXIT FOR, EXIT WHILE, EXIT DO, EXIT SELECT
    - SWAP (numeric and string variables)
    - DATA/READ/RESTORE for embedded data tables
    - File I/O: OPEN/CLOSE, PRINT#/INPUT#, EOF
    - File management: KILL, NAME...AS, MKDIR, RMDIR
    - Exponentiation operator: ^ (right-associative, returns f32)
    - ELSEIF keyword (equivalent to ELSE IF)
    - LBOUND() function (always returns 1)

  Additions (string):
    - String variables (A$, NAME$, etc.)
    - String concatenation with +
    - String comparison (=, <>, <, >, <=, >=)
    - String functions: LEN, MID$, LEFT$, RIGHT$, CHR$, ASC, STR$,
      VAL, VAL#, UPPER$/UCASE$, LOWER$/LCASE$, INSTR, TRIM$,
      LTRIM$, RTRIM$, STRING$, SPACE$, HEX$, OCT$
    - MID$ assignment for in-place string modification

  Unsupported:
    - RESUME (interpreter-specific, compile-time error)

  Behavioral:
    - BREAK compiles to a function return (not a block break)
    - Compiled code runs ~10x faster than interpreted


Floating-Point Support
----------------------

The BASIC interpreter is integer-only. The compiler extends the language
with f32 (32-bit float) support, taking advantage of WASM's native float
instructions. This is a compiler-only extension — the interpreter is unchanged.

Type Rules:

  Variables are typed i32 (integer), f32 (float), or str (string). The
  type is determined by the variable name or first value assigned:

    X = 42            ' X is i32
    Y = 3.14          ' Y is f32 (number contains a decimal point)
    Z = GPSLAT#()     ' Z is f32 (# function returns float)
    A$ = "hello"      ' A$ is str ($ suffix = string variable)
    PI# = 3.14159     ' PI# is f32 (# suffix = float variable)

  String variables must have a $ suffix. Float variables can use a # suffix.
  Numeric variables without a suffix default to i32.

  In mixed arithmetic, i32 values are promoted to f32 automatically:

    A = 10            ' i32
    B = 2.5           ' f32
    C = A * B         ' C is f32 (A promoted to f32 for multiply)

  Assignment to a typed variable coerces the value:

    X = 42            ' X is i32
    X = 3.14          ' 3.14 is truncated to 3

  String variables cannot be assigned numeric values or vice versa.


Float Literals:

  Any number with a decimal point is a float literal:

    X = 3.14
    Y = 0.5
    Z = 1.0           ' float, not integer (has decimal point)


Math Functions (compiler-only):

  SIN(x)              Sine. Input in radians, returns f32.
  COS(x)              Cosine. Input in radians, returns f32.
  TAN(x)              Tangent. Input in radians, returns f32.
  SQRT(x)             Square root. Returns f32.
  ATAN2(y, x)         Two-argument arctangent. Returns f32 radians.
  POW(base, exp)      Exponentiation. Returns f32.
  EXP(x)              e^x. Returns f32.
  LOG(x)              Natural logarithm. Returns f32.
  LOG2(x)             Base-2 logarithm. Returns f32.
  FLOOR(x)            Floor (round toward -infinity). Returns f32.
  CEIL(x)             Ceiling (round toward +infinity). Returns f32.
  FMOD(x, y)          Floating-point remainder. Returns f32.
  SGN(x)              Sign: returns 1, 0, or -1 (i32). Works on i32 or f32.

Type Conversion:

  INT(x)              Convert f32 to i32 (truncate toward zero).
  FLOAT(x)            Convert i32 to f32.

Operators (compiler-only):

  NOT x               Bitwise NOT (unary). Returns i32.
  x XOR y             Bitwise XOR (binary). Returns i32.

  NOT and XOR use BASIC truth values (-1 = true, 0 = false):

    NOT -1 = 0        NOT 0 = -1
    -1 XOR -1 = 0     -1 XOR 0 = -1     0 XOR 0 = 0


Exponentiation:

  x ^ y               Power (x raised to y). Right-associative.
                       Both operands coerced to f32, result is f32.

    2 ^ 3 = 8.0       ' 2 cubed
    2 ^ 0.5 = 1.414   ' square root of 2
    2 ^ 3 ^ 2 = 512   ' right-associative: 2^(3^2) = 2^9

  The ^ operator has higher precedence than * / \ MOD.
  The POW(x, y) function is equivalent.


Integer Division and Modulo:

  \                   Integer division (QuickBASIC compatible).
  MOD                 Modulo / integer remainder (QuickBASIC keyword).

  Both operators coerce their operands to i32 before the operation:

    17 \ 3 = 5        ' integer division
    17 MOD 3 = 2      ' remainder

  In the interpreter, \ and MOD are also available.


Comments:

  Comments use the apostrophe (') character, matching QuickBASIC syntax:

    ' This is a comment
    X = 42  ' inline comment


NEXT and WEND:

  FOR loops are closed with NEXT:

    FOR I = 1 TO 10
      ...
    NEXT

  WHILE loops are closed with WEND:

    WHILE condition
      ...
    WEND

  NEXT and WEND are supported in both the interpreter and compiler.


FUNCTION:

  FUNCTION is an alias for SUB. Both define a callable subroutine that
  can return a value via RETURN:

    FUNCTION DOUBLE X
      RETURN X * 2
    END FUNCTION

    FORMAT "result=%", DOUBLE(5)

  This is equivalent to:

    SUB DOUBLE X
      RETURN X * 2
    END SUB

  SUB/FUNCTION supports all three types for parameters, locals, and
  return values. The type follows the normal naming convention:

    SUB GREET$ NAME$           ' string param, string return
      RETURN "Hello, " + NAME$
    END SUB

    SUB AVERAGE# X#, Y#       ' float params, float return
      RETURN (X# + Y#) / 2.0
    END SUB

    SUB COUNTCHARS S$, C$      ' string params, integer return
      LOCAL I
      LOCAL N
      N = 0
      FOR I = 1 TO LEN(S$)
        IF MID$(S$, I, 1) = C$ THEN N = N + 1
      NEXT I
      RETURN N
    END SUB

  LOCAL variables also support all three types:

    SUB EXAMPLE X
      LOCAL TEMP#              ' float local
      LOCAL MSG$               ' string local
      TEMP# = FLOAT(X) * 1.5
      MSG$ = "Value: " + STR$(TEMP#)
      PRINTS MSG$
    END SUB

  FUNCTION is supported in both the interpreter and compiler.


Constants (compiler-only):

  CONST name = value

  Declares a named constant. The value is stored like a variable but
  subsequent assignment is a compile-time error:

    CONST PI = 3.14159
    CONST MAX = 100
    CONST GREETING$ = "Hello"
    PI = 2.0              ' ERROR: cannot assign to CONST


Float Sensor Functions:

  The interpreter's sensor functions truncate float values to integers.
  The compiler provides # variants that return the native f32 value:

  Function            Interpreter (i32)    Compiler # variant (f32)
  --------            -----------------    ------------------------
  GPSLAT#()           n/a                  Latitude as f32
  GPSLON#()           n/a                  Longitude as f32
  GPSALT#()           GPSALT() truncated   Altitude as f32
  GPSSPEED#()         GPSSPEED() truncated Speed as f32
  GPSDIR#()           GPSDIR() truncated   Direction as f32
  ORIGINDIST#()       ORIGINDIST() trunc   Distance as f32 meters
  ORIGINANGLE#()      ORIGINANGLE() trunc  Bearing as f32 degrees
  PITCH#()            PITCH() truncated    Pitch as f32 degrees
  ROLL#()             ROLL() truncated     Roll as f32 degrees
  YAW#()              YAW() truncated      Yaw as f32 degrees
  ACCX#()             ACCX() truncated     Accel X as f32
  ACCY#()             ACCY() truncated     Accel Y as f32
  ACCZ#()             ACCZ() truncated     Accel Z as f32
  TEMP#()             TEMP() returns C*10  Temperature as f32 C
  HUM#()              HUM() truncated      Humidity as f32
  BRIGHT#()           BRIGHT() truncated   Brightness as f32
  BATPCT#()           BATPCT() truncated   Battery % as f32 (-1000 if n/a)
  BATRUNTIME#()       BATRUNTIME() trunc   Runtime as f32 (-1000 if n/a)
  SUNAZ#()            SUNAZ() truncated    Sun azimuth as f32 degrees
  SUNEL#()            SUNEL() truncated    Sun elevation as f32 degrees

  Note: TEMP#() returns degrees C as a float (e.g. 22.5), while the
  interpreter's TEMP() returns C*10 as an integer (e.g. 225).


Output with Floats:

  > expr
      Automatically calls print_f32 if the expression is f32,
      print_str if str, or print_i32 if i32.

  FORMAT "...", args
      Use & as a float placeholder (in addition to % for int, $ for string):

      LAT = GPSLAT#()
      FORMAT "Latitude: &", LAT


String Support
--------------

The compiler extends the language with string variables and functions.
String values are pointers into WASM linear memory (null-terminated C
strings). The runtime manages a string pool in the 0x8000-0xEFFF region
for dynamically allocated strings.


String Variables:

  Variables ending in $ are string-typed:

    A$ = "Hello"
    NAME$ = "ConeZ"

  String variables can hold string literals, results of string functions,
  or concatenation results. They are initialized to 0 (empty/null).


String Concatenation:

  The + operator concatenates strings:

    A$ = "Hello"
    B$ = " World"
    C$ = A$ + B$          ' C$ is "Hello World"

  Both operands must be strings. Mixing strings and numbers is an error.


String Comparison:

  All six comparison operators work on strings (lexicographic order):

    IF A$ = "Hello" THEN ...
    IF A$ <> B$ THEN ...
    IF A$ < B$ THEN ...
    IF A$ > B$ THEN ...
    IF A$ <= B$ THEN ...
    IF A$ >= B$ THEN ...

  Both operands must be strings.


String Functions:

  LEN(s$)                 Length of string. Returns i32.
  MID$(s$, start, len)    Substring. start is 1-based. Returns str.
  LEFT$(s$, n)            First n characters. Returns str.
  RIGHT$(s$, n)           Last n characters. Returns str.
  CHR$(n)                 Character from ASCII code. Returns str.
  ASC(s$)                 ASCII code of first character. Returns i32.
  STR$(x)                 Number to string (works with i32 or f32). Returns str.
  VAL(s$)                 String to integer. Returns i32.
  VAL#(s$)                String to float. Returns f32.
  UPPER$(s$)              Convert to uppercase. Returns str.
  UCASE$(s$)              Alias for UPPER$.
  LOWER$(s$)              Convert to lowercase. Returns str.
  LCASE$(s$)              Alias for LOWER$.
  INSTR(s$, sub$)         Find substring (1-based, 0 if not found). Returns i32.
  INSTR(s$, sub$, start)  Find substring from position. Returns i32.
  TRIM$(s$)               Remove leading/trailing whitespace. Returns str.
  LTRIM$(s$)              Remove leading whitespace. Returns str.
  RTRIM$(s$)              Remove trailing whitespace. Returns str.
  STRING$(n, code)        String of n copies of CHR$(code). Returns str.
  SPACE$(n)               String of n spaces. Returns str.
  HEX$(n)                 Integer to hex string (e.g. 255 -> "FF"). Returns str.
  OCT$(n)                 Integer to octal string (e.g. 255 -> "377"). Returns str.

  Examples:

    NAME$ = "ConeZ"
    FORMAT "Length: %", LEN(NAME$)       ' 5
    FORMAT "Sub: $", MID$(NAME$, 2, 3)   ' one
    FORMAT "Upper: $", UPPER$(NAME$)     ' CONEZ
    FORMAT "Code: %", ASC("A")           ' 65
    FORMAT "Char: $", CHR$(65)           ' A
    FORMAT "Num: $", STR$(42)            ' 42

    IF INSTR(NAME$, "one") > 0 THEN FORMAT "Found!"


ELSEIF (compiler-only)
---------------------

  ELSEIF provides a shorthand for ELSE IF in multi-line IF blocks.
  An optional THEN keyword is accepted but not required.

    IF x = 1
        FORMAT "one"
    ELSEIF x = 2
        FORMAT "two"
    ELSEIF x = 3
        FORMAT "three"
    ELSE
        FORMAT "other"
    END IF

  This is equivalent to nested ELSE IF:

    IF x = 1
        FORMAT "one"
    ELSE IF x = 2
        FORMAT "two"
    ELSE
        FORMAT "other"
    END IF


LBOUND (compiler-only)
----------------------

  LBOUND(array) returns the lower bound of an array. Since all arrays in
  ConeZ BASIC are 1-based, this always returns 1.

    DIM A(100)
    FORMAT "Lower: %", LBOUND(A)   ' 1
    FORMAT "Upper: %", UBOUND(A)   ' 100


DIM / REDIM / ERASE (compiler-only)
-----------------------------------

  Arrays support 1..8 dimensions and 1-based indexing.

    DIM A(10)
    DIM M(8, 8)
    A(1) = 42
    M(3, 4) = 7

  REDIM reallocates an existing array with a new shape:

    REDIM M(16, 16)

  REDIM PRESERVE keeps existing values and resizes the array:

    REDIM PRESERVE M(8, 16)

  REDIM PRESERVE currently requires the same number of dimensions.
  If the new shape is larger, added elements are zero-initialized.

  ERASE frees one or more DIM arrays and sets their pointers to null:

    ERASE A
    ERASE A, M

  UBOUND supports an optional dimension argument:

    UBOUND(M)      ' upper bound of dimension 1
    UBOUND(M, 2)   ' upper bound of dimension 2


SELECT CASE (compiler-only)
--------------------------

  SELECT CASE evaluates an expression once and branches to the matching
  CASE block. The test expression can be integer, float, or string.

  Syntax:

    SELECT CASE expr
      CASE value1
        ...
      CASE value2, value3        ' comma-separated match values
        ...
      CASE IS > value4           ' comparison with IS keyword
        ...
      CASE ELSE                  ' default (optional, must be last)
        ...
    END SELECT

  Match forms:
    CASE 1              Exact match (== comparison)
    CASE 1, 2, 3        Match any of the listed values (OR'd together)
    CASE IS > 10        Comparison: =, <>, <, >, <=, >= after IS
    CASE ELSE           Matches if no previous CASE matched

  The test expression type determines how comparisons work:
    Integer: i32 comparisons
    Float:   f32 comparisons
    String:  lexicographic comparison via str_cmp

  Examples:

    X = 3
    SELECT CASE X
      CASE 1
        FORMAT "one"
      CASE 2, 3
        FORMAT "two or three"
      CASE IS > 10
        FORMAT "big"
      CASE ELSE
        FORMAT "other"
    END SELECT

    S$ = "hello"
    SELECT CASE S$
      CASE "world"
        FORMAT "world"
      CASE "hello"
        FORMAT "hello!"
    END SELECT


DO...LOOP (compiler-only)
-------------------------

  DO...LOOP provides five looping variants:

    DO                        Infinite loop (use EXIT DO to break)
      ...
    LOOP

    DO WHILE condition        Pre-condition: loop while true
      ...
    LOOP

    DO UNTIL condition        Pre-condition: loop until true
      ...
    LOOP

    DO                        Post-condition: body runs at least once
      ...
    LOOP WHILE condition

    DO                        Post-condition: body runs at least once
      ...
    LOOP UNTIL condition

  Pre-condition loops test before each iteration (body may run 0 times).
  Post-condition loops test after each iteration (body runs at least once).

  Examples:

    I = 0
    DO WHILE I < 10
      > I
      I = I + 1
    LOOP

    I = 0
    DO
      > I
      I = I + 1
    LOOP UNTIL I >= 10


EXIT Statement (compiler-only)
------------------------------

  EXIT breaks out of a loop or SELECT CASE:

    EXIT FOR        Break out of the nearest FOR loop
    EXIT WHILE      Break out of the nearest WHILE loop
    EXIT DO         Break out of the nearest DO loop
    EXIT SELECT     Break out of the nearest SELECT CASE

  EXIT searches outward through nested blocks to find the matching
  control structure. It jumps past the end of that structure.

  Example:

    FOR I = 0 TO 1000
      IF I = 42 THEN EXIT FOR
    NEXT
    > I              ' prints 42


SWAP (compiler-only)
--------------------

  SWAP exchanges the values of two variables:

    SWAP A, B        Swap two numeric variables
    SWAP A$, B$      Swap two string variables

  Both variables must be the same type (both i32, both f32, or both str).

  Example:

    A = 10
    B = 20
    SWAP A, B
    FORMAT "A=%, B=%", A, B    ' A=20, B=10


DATA/READ/RESTORE (compiler-only)
----------------------------------

  DATA embeds literal values into the program. READ retrieves them
  sequentially. RESTORE resets the read pointer to the beginning.

  DATA values can be integers, floats, or strings:

    DATA 10, 20, 30
    READ A, B, C
    FORMAT "%, %, %", A, B, C    ' 10, 20, 30

  All DATA statements across the program form a single sequential table.
  READ advances through the table one item at a time. The type of each
  item is stored alongside its value, so a single DATA line can contain
  mixed types:

    DATA 42, 3.14, "hello"
    READ I, F, S$
    FORMAT "%, &, $", I, F, S$   ' 42, 3.14, hello

  Type conversion happens automatically on READ:
    - Reading a float into an i32 variable truncates it
    - Reading an integer into an f32 variable converts it
    - Reading a string into a string variable copies it to the pool

  RESTORE resets the read pointer to the first DATA item:

    DATA 1, 2, 3
    READ A, B, C
    RESTORE
    READ X              ' X = 1 (first item again)

  Negative numbers are supported in DATA:

    DATA -10, -3.14

  DATA statements can appear anywhere in the program. They produce no
  runtime code — values are collected at compile time and stored in the
  WASM data section. Multiple DATA lines are concatenated in order.

  Common use: LED color tables, animation sequences, coordinate lists.

  Example — color table:

    DATA 255, 0, 0,  0, 255, 0,  0, 0, 255
    FOR I = 0 TO 2
      READ R, G, B
      SETLEDCOL(R, G, B)
      WAIT(500)
    NEXT


MID$ Assignment (compiler-only)
-------------------------------

  MID$ can be used on the left side of an assignment to replace characters
  in a string variable in place (QuickBASIC semantics):

    MID$(target$, start, length) = replacement$

  Replaces up to `length` characters in `target$` starting at position
  `start` (1-based) with characters from `replacement$`. The result has
  the same length as the original string — it never grows or shrinks.

  The number of characters actually replaced is the minimum of:
    - `length`
    - LEN(replacement$)
    - remaining characters from `start` to end of `target$`

  Examples:

    A$ = "Hello World"
    MID$(A$, 7, 5) = "Earth"
    FORMAT "$", A$               ' Hello Earth

    B$ = "ABCDEF"
    MID$(B$, 3, 2) = "XX"
    FORMAT "$", B$               ' ABXXEF

    C$ = "0123456789"
    MID$(C$, 1, 3) = "ABC"
    FORMAT "$", C$               ' ABC3456789


Constant Folding
----------------

The compiler performs peephole constant folding during code generation.
Adjacent constant expressions are evaluated at compile time and replaced
with a single constant instruction. This reduces code size and eliminates
runtime arithmetic for literal expressions.

Folded operations:

  Arithmetic:   +  -  *  /  (i32, f32, and mixed i32/f32)
  Integer:      \  MOD       (i32 only, skipped if divisor is 0)
  Power:        ^            (constant base and exponent)
  Negation:     -expr        (unary minus on a constant)

Folding chains across subexpressions:

    1 + 2 + 3 + 4            →  i32.const 10       (single instruction)
    1.5 * 2.0                →  f32.const 3.0
    2 + 3.0                  →  f32.const 5.0       (mixed: promoted to f32)
    2.0 ^ 3.0                →  f32.const 8.0
    10 \ 3                   →  i32.const 3
    10 MOD 3                 →  i32.const 1
    -42                      →  i32.const -42        (not 0 - 42)

Mixed constant+variable expressions partially fold:

    2 + 3 + X                →  i32.const 5; global.get X; i32.add

Division and modulo by zero are left as runtime operations (WASM trap).


Compiled Output
---------------

The compiler produces a valid WASM 1.0 binary with these sections:

  Type       Function signatures
  Import     Host API functions used by the program
  Function   Type indices for local functions (setup + SUBs)
  Memory     1 page (64KB)
  Global     All BASIC variables as mutable globals + heap pointer
  Export     setup function + memory + __line global
  Code       Function bodies as WASM bytecode
  Data       String constants

Only imports that the program actually uses are included — a simple program
that uses GETPARAM and FORMAT will import just those two functions.

Memory layout:

  [0 .. data_end)       String constants
  [data_end .. heap)    Reserved (heap pointer global)
  [0x8000 .. 0xEFFF)   String pool (host-managed, for runtime strings)
  [0xF000 .. 0xF100)   FORMAT argument buffer (scratch space)
  [0xF100 .. 0xF110)   File handle table (4 x i32, init to -1)

Variables are WASM globals (not in linear memory). DIM arrays are allocated
via host imports (calloc/free/realloc) in WASM linear memory with a small
header containing dimension metadata.

The exported `__line` global (mutable i32) tracks the current BASIC source
line number. The compiler emits a `global.set __line` at the start of each
statement. The WASM runtime reads this on error to report the originating
BASIC line (e.g. "wasm: loop() error: trap (BASIC line 42)"). Hand-written
WASM modules that don't export `__line` are unaffected.


SUB Compilation
---------------

SUBs compile to WASM functions. Parameters become WASM function params.
The compiler saves and restores global values for parameter variables,
matching the BASIC interpreter's shadowing semantics:

  SUB FOO A, B
      LOCAL C
      ...
  END SUB

Compiles to a WASM function that:
  1. Saves current values of globals A and B
  2. Installs parameter values into globals A and B
  3. Executes the body (LOCAL C becomes a WASM local)
  4. Restores globals A and B
  5. Returns (default 0/0.0/"", or RETURN value)

The return type is determined by the SUB name suffix:
  - No suffix: returns i32 (e.g. SUB COUNT)
  - # suffix:  returns f32 (e.g. SUB AVERAGE#)
  - $ suffix:  returns str (e.g. SUB GREET$)

All three types are supported for parameters and LOCAL variables.
At the WASM level, strings are i32 pointers, so string parameters
use WASM i32 type.

String parameter handling:
  - On entry, each string parameter is copied via str_copy to prevent
    the callee from aliasing the caller's string
  - On exit, all string parameter copies are freed via str_free

String LOCAL handling:
  - On entry, the global is saved and zeroed (starts as empty string)
  - On exit, the local string is freed via str_free, then the global
    is restored


FOR Loop Semantics
------------------

  FOR I = 0 TO N
  FOR I = 0 TO 100 STEP 5
  FOR I = 10 TO 0 STEP -1

The loop variable increments by 1 each iteration (or by the STEP value
if specified). The loop exits when the variable reaches the TO value
(exclusive upper bound — matching the interpreter's behavior).

Without STEP, FOR I = 0 TO 10 runs for I = 0, 1, ..., 9.

With a positive STEP, the loop exits when I >= limit.
With a negative STEP, the loop exits when I <= limit. The direction
check is automatic at runtime based on the sign of the step value.


File I/O (compiler-only)
------------------------

The compiler supports QuickBASIC-compatible file I/O using channels 1-4
(matching the WASM runtime's 4-file limit).

Syntax:

  OPEN "/data.txt" FOR INPUT AS #1      ' open for reading
  OPEN "/data.txt" FOR OUTPUT AS #2     ' open for writing (creates/truncates)
  OPEN "/data.txt" FOR APPEND AS #3     ' open for appending

  CLOSE #1                              ' close a channel

  PRINT #1, expr                        ' write value + newline
  PRINT #1, A$                          ' write string + newline
  PRINT #1, 42                          ' write "42\n"
  PRINT #1, 3.14                        ' write "3.14\n"

  INPUT #1, A$                          ' read line into string variable
  INPUT #1, X                           ' read line, convert to integer
  INPUT #1, F#                          ' read line, convert to float

  IF EOF(1) THEN ...                    ' -1 at EOF, 0 otherwise (QB convention)

Modes:
  INPUT    Open for reading. File must exist.
  OUTPUT   Open for writing. Creates file or truncates existing.
  APPEND   Open for appending. Creates file if it doesn't exist.

Channels:
  Channels 1-4 are available (# prefix required). Each channel holds one
  open file handle. Opening a new file on an already-open channel does not
  automatically close the previous file — use CLOSE first.

Path rules (same as WASM runtime):
  - Paths must start with /
  - No .. (path traversal blocked)
  - /config.ini is protected (cannot be opened)
  - Maximum path length: 127 characters

PRINT # writes the expression value as a string followed by a newline.
Numeric values are automatically converted to strings (integers via STR$,
floats via STR$).

INPUT # reads one line from the file (up to 255 characters). The line is
converted to the target variable's type: strings are stored directly,
integers use VAL(), floats use VAL#().

EOF(n) returns -1 (true) when channel n has no more data, 0 (false)
otherwise. This follows the QuickBASIC convention where true = -1.

File management statements (QuickBASIC-compatible):

  KILL "/file.txt"                      ' delete a file
  NAME "/old.txt" AS "/new.txt"         ' rename a file
  MKDIR "/subdir"                       ' create a directory
  RMDIR "/subdir"                       ' remove an empty directory

All take string expressions (not just literals):

  PATH$ = "/data"
  MKDIR PATH$
  KILL PATH$ + "/temp.txt"

Example:

  ' Write data
  OPEN "/test_io.txt" FOR OUTPUT AS #1
  PRINT #1, "Hello World"
  PRINT #1, 42
  PRINT #1, 3.14
  CLOSE #1

  ' Read it back
  OPEN "/test_io.txt" FOR INPUT AS #2
  WHILE NOT EOF(2)
      INPUT #2, LINE$
      FORMAT "Read: $", LINE$
  WEND
  CLOSE #2


Limitations
-----------

  - 256 max variables/arrays/subroutines
  - 64 max local functions (SUBs)
  - 8KB string constant table
  - 64KB linear memory (1 WASM page)
  - No nested SUB definitions
  - RESUME is not supported (compile-time error)
  - Array operations (SETARRAY, SHIFTARRAY, ROTATEARRAY, COPYARRAY,
    SCALELIMITARRAY, RGBTOHSVARRAY, HSVTORGBARRAY) are not yet implemented
  - SETLEDRGB is not yet implemented (use per-pixel LED functions instead)
