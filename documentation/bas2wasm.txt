bas2wasm — BASIC to WASM Compiler
===================================

bas2wasm compiles ConeZ BASIC scripts (.bas) into WASM 1.0 binaries (.wasm)
that run on the ConeZ WASM runtime. The compiled output uses the same host
API as hand-written WASM modules (see wasm-api.txt).

The compiler is a single C file with no dependencies beyond libc. It can be
built on any system with a C compiler:

    cc -o bas2wasm tools/bas2wasm/bas2wasm.c
    ./bas2wasm script.bas -o script.wasm

The .wasm file can then be uploaded to the ConeZ filesystem and run with:

    run /script.wasm


Differences from the BASIC Interpreter
---------------------------------------

The compiler accepts the same language as the interpreter (see
basic-scripting.txt) with the following differences:

  Additions:
    - Floating-point variables and arithmetic (f32)
    - Float math functions: SIN, COS, SQRT, ATAN2, POW, TAN, EXP,
      LOG, LOG2, FLOOR, CEIL, FMOD, SGN
    - Type conversion functions: INT, FLOAT
    - Float-returning sensor functions with # suffix
    - FORMAT & placeholder for printing floats
    - CONST declarations
    - NOT (unary) and XOR (binary) operators
    - FOR STEP support
    - SELECT CASE (with multi-value, IS comparisons, ELSE)
    - DO...LOOP (all 5 variants: infinite, pre/post WHILE/UNTIL)
    - EXIT FOR, EXIT WHILE, EXIT DO, EXIT SELECT
    - SWAP (numeric and string variables)
    - DATA/READ/RESTORE for embedded data tables

  Additions (string):
    - String variables (A$, NAME$, etc.)
    - String concatenation with +
    - String comparison (=, <>, <, >, <=, >=)
    - String functions: LEN, MID$, LEFT$, RIGHT$, CHR$, ASC, STR$,
      VAL, VAL#, UPPER$, LOWER$, INSTR, TRIM$, STRING$, SPACE$,
      HEX$, OCT$
    - MID$ assignment for in-place string modification

  Unsupported:
    - RESUME (interpreter-specific, compile-time error)

  Behavioral:
    - BREAK compiles to a function return (not a block break)
    - Compiled code runs ~10x faster than interpreted


Floating-Point Support
----------------------

The BASIC interpreter is integer-only. The compiler extends the language
with f32 (32-bit float) support, taking advantage of WASM's native float
instructions. This is a compiler-only extension — the interpreter is unchanged.

Type Rules:

  Variables are typed i32 (integer), f32 (float), or str (string). The
  type is determined by the variable name or first value assigned:

    X = 42            # X is i32
    Y = 3.14          # Y is f32 (number contains a decimal point)
    Z = GPSLAT#()     # Z is f32 (# function returns float)
    A$ = "hello"      # A$ is str ($ suffix = string variable)

  String variables must have a $ suffix. Numeric variables cannot end in $.

  In mixed arithmetic, i32 values are promoted to f32 automatically:

    A = 10            # i32
    B = 2.5           # f32
    C = A * B         # C is f32 (A promoted to f32 for multiply)

  Assignment to a typed variable coerces the value:

    X = 42            # X is i32
    X = 3.14          # 3.14 is truncated to 3

  String variables cannot be assigned numeric values or vice versa.


Float Literals:

  Any number with a decimal point is a float literal:

    X = 3.14
    Y = 0.5
    Z = 1.0           # float, not integer (has decimal point)


Math Functions (compiler-only):

  SIN(x)              Sine. Input in radians, returns f32.
  COS(x)              Cosine. Input in radians, returns f32.
  TAN(x)              Tangent. Input in radians, returns f32.
  SQRT(x)             Square root. Returns f32.
  ATAN2(y, x)         Two-argument arctangent. Returns f32 radians.
  POW(base, exp)      Exponentiation. Returns f32.
  EXP(x)              e^x. Returns f32.
  LOG(x)              Natural logarithm. Returns f32.
  LOG2(x)             Base-2 logarithm. Returns f32.
  FLOOR(x)            Floor (round toward -infinity). Returns f32.
  CEIL(x)             Ceiling (round toward +infinity). Returns f32.
  FMOD(x, y)          Floating-point remainder. Returns f32.
  SGN(x)              Sign: returns 1, 0, or -1 (i32). Works on i32 or f32.

Type Conversion:

  INT(x)              Convert f32 to i32 (truncate toward zero).
  FLOAT(x)            Convert i32 to f32.

Operators (compiler-only):

  NOT x               Bitwise NOT (unary). Returns i32.
  x XOR y             Bitwise XOR (binary). Returns i32.

  NOT and XOR use BASIC truth values (-1 = true, 0 = false):

    NOT -1 = 0        NOT 0 = -1
    -1 XOR -1 = 0     -1 XOR 0 = -1     0 XOR 0 = 0


Constants (compiler-only):

  CONST name = value

  Declares a named constant. The value is stored like a variable but
  subsequent assignment is a compile-time error:

    CONST PI = 3.14159
    CONST MAX = 100
    CONST GREETING$ = "Hello"
    PI = 2.0              # ERROR: cannot assign to CONST


Float Sensor Functions:

  The interpreter's sensor functions truncate float values to integers.
  The compiler provides # variants that return the native f32 value:

  Function            Interpreter (i32)    Compiler # variant (f32)
  --------            -----------------    ------------------------
  GPSLAT#()           n/a                  Latitude as f32
  GPSLON#()           n/a                  Longitude as f32
  GPSALT#()           GPSALT() truncated   Altitude as f32
  GPSSPEED#()         GPSSPEED() truncated Speed as f32
  GPSDIR#()           GPSDIR() truncated   Direction as f32
  ORIGINDIST#()       ORIGINDIST() trunc   Distance as f32 meters
  ORIGINANGLE#()      ORIGINANGLE() trunc  Bearing as f32 degrees
  PITCH#()            PITCH() truncated    Pitch as f32 degrees
  ROLL#()             ROLL() truncated     Roll as f32 degrees
  YAW#()              YAW() truncated      Yaw as f32 degrees
  ACCX#()             ACCX() truncated     Accel X as f32
  ACCY#()             ACCY() truncated     Accel Y as f32
  ACCZ#()             ACCZ() truncated     Accel Z as f32
  TEMP#()             TEMP() returns C*10  Temperature as f32 C
  HUM#()              HUM() truncated      Humidity as f32
  BRIGHT#()           BRIGHT() truncated   Brightness as f32
  BATPCT#()           BATPCT() truncated   Battery % as f32 (-1000 if n/a)
  BATRUNTIME#()       BATRUNTIME() trunc   Runtime as f32 (-1000 if n/a)
  SUNAZ#()            SUNAZ() truncated    Sun azimuth as f32 degrees
  SUNEL#()            SUNEL() truncated    Sun elevation as f32 degrees

  Note: TEMP#() returns degrees C as a float (e.g. 22.5), while the
  interpreter's TEMP() returns C*10 as an integer (e.g. 225).


Output with Floats:

  > expr
      Automatically calls print_f32 if the expression is f32,
      print_str if str, or print_i32 if i32.

  FORMAT "...", args
      Use & as a float placeholder (in addition to % for int, $ for string):

      LAT = GPSLAT#()
      FORMAT "Latitude: &", LAT


String Support
--------------

The compiler extends the language with string variables and functions.
String values are pointers into WASM linear memory (null-terminated C
strings). The runtime manages a string pool in the 0x8000-0xEFFF region
for dynamically allocated strings.


String Variables:

  Variables ending in $ are string-typed:

    A$ = "Hello"
    NAME$ = "ConeZ"

  String variables can hold string literals, results of string functions,
  or concatenation results. They are initialized to 0 (empty/null).


String Concatenation:

  The + operator concatenates strings:

    A$ = "Hello"
    B$ = " World"
    C$ = A$ + B$          # C$ is "Hello World"

  Both operands must be strings. Mixing strings and numbers is an error.


String Comparison:

  All six comparison operators work on strings (lexicographic order):

    IF A$ = "Hello" THEN ...
    IF A$ <> B$ THEN ...
    IF A$ < B$ THEN ...
    IF A$ > B$ THEN ...
    IF A$ <= B$ THEN ...
    IF A$ >= B$ THEN ...

  Both operands must be strings.


String Functions:

  LEN(s$)                 Length of string. Returns i32.
  MID$(s$, start, len)    Substring. start is 1-based. Returns str.
  LEFT$(s$, n)            First n characters. Returns str.
  RIGHT$(s$, n)           Last n characters. Returns str.
  CHR$(n)                 Character from ASCII code. Returns str.
  ASC(s$)                 ASCII code of first character. Returns i32.
  STR$(x)                 Number to string (works with i32 or f32). Returns str.
  VAL(s$)                 String to integer. Returns i32.
  VAL#(s$)                String to float. Returns f32.
  UPPER$(s$)              Convert to uppercase. Returns str.
  LOWER$(s$)              Convert to lowercase. Returns str.
  INSTR(s$, sub$)         Find substring (1-based, 0 if not found). Returns i32.
  INSTR(s$, sub$, start)  Find substring from position. Returns i32.
  TRIM$(s$)               Remove leading/trailing whitespace. Returns str.
  STRING$(n, code)        String of n copies of CHR$(code). Returns str.
  SPACE$(n)               String of n spaces. Returns str.
  HEX$(n)                 Integer to hex string (e.g. 255 -> "FF"). Returns str.
  OCT$(n)                 Integer to octal string (e.g. 255 -> "377"). Returns str.

  Examples:

    NAME$ = "ConeZ"
    FORMAT "Length: %", LEN(NAME$)       # 5
    FORMAT "Sub: $", MID$(NAME$, 2, 3)   # one
    FORMAT "Upper: $", UPPER$(NAME$)     # CONEZ
    FORMAT "Code: %", ASC("A")           # 65
    FORMAT "Char: $", CHR$(65)           # A
    FORMAT "Num: $", STR$(42)            # 42

    IF INSTR(NAME$, "one") > 0 THEN FORMAT "Found!"


SELECT CASE (compiler-only)
--------------------------

  SELECT CASE evaluates an expression once and branches to the matching
  CASE block. The test expression can be integer, float, or string.

  Syntax:

    SELECT CASE expr
      CASE value1
        ...
      CASE value2, value3        ' comma-separated match values
        ...
      CASE IS > value4           ' comparison with IS keyword
        ...
      CASE ELSE                  ' default (optional, must be last)
        ...
    END SELECT

  Match forms:
    CASE 1              Exact match (== comparison)
    CASE 1, 2, 3        Match any of the listed values (OR'd together)
    CASE IS > 10        Comparison: =, <>, <, >, <=, >= after IS
    CASE ELSE           Matches if no previous CASE matched

  The test expression type determines how comparisons work:
    Integer: i32 comparisons
    Float:   f32 comparisons
    String:  lexicographic comparison via str_cmp

  Examples:

    X = 3
    SELECT CASE X
      CASE 1
        FORMAT "one"
      CASE 2, 3
        FORMAT "two or three"
      CASE IS > 10
        FORMAT "big"
      CASE ELSE
        FORMAT "other"
    END SELECT

    S$ = "hello"
    SELECT CASE S$
      CASE "world"
        FORMAT "world"
      CASE "hello"
        FORMAT "hello!"
    END SELECT


DO...LOOP (compiler-only)
-------------------------

  DO...LOOP provides five looping variants:

    DO                        Infinite loop (use EXIT DO to break)
      ...
    LOOP

    DO WHILE condition        Pre-condition: loop while true
      ...
    LOOP

    DO UNTIL condition        Pre-condition: loop until true
      ...
    LOOP

    DO                        Post-condition: body runs at least once
      ...
    LOOP WHILE condition

    DO                        Post-condition: body runs at least once
      ...
    LOOP UNTIL condition

  Pre-condition loops test before each iteration (body may run 0 times).
  Post-condition loops test after each iteration (body runs at least once).

  Examples:

    I = 0
    DO WHILE I < 10
      > I
      I = I + 1
    LOOP

    I = 0
    DO
      > I
      I = I + 1
    LOOP UNTIL I >= 10


EXIT Statement (compiler-only)
------------------------------

  EXIT breaks out of a loop or SELECT CASE:

    EXIT FOR        Break out of the nearest FOR loop
    EXIT WHILE      Break out of the nearest WHILE loop
    EXIT DO         Break out of the nearest DO loop
    EXIT SELECT     Break out of the nearest SELECT CASE

  EXIT searches outward through nested blocks to find the matching
  control structure. It jumps past the end of that structure.

  Example:

    FOR I = 0 TO 1000
      IF I = 42 THEN EXIT FOR
    END FOR
    > I              # prints 42


SWAP (compiler-only)
--------------------

  SWAP exchanges the values of two variables:

    SWAP A, B        Swap two numeric variables
    SWAP A$, B$      Swap two string variables

  Both variables must be the same type (both i32, both f32, or both str).

  Example:

    A = 10
    B = 20
    SWAP A, B
    FORMAT "A=%, B=%", A, B    # A=20, B=10


DATA/READ/RESTORE (compiler-only)
----------------------------------

  DATA embeds literal values into the program. READ retrieves them
  sequentially. RESTORE resets the read pointer to the beginning.

  DATA values can be integers, floats, or strings:

    DATA 10, 20, 30
    READ A, B, C
    FORMAT "%, %, %", A, B, C    # 10, 20, 30

  All DATA statements across the program form a single sequential table.
  READ advances through the table one item at a time. The type of each
  item is stored alongside its value, so a single DATA line can contain
  mixed types:

    DATA 42, 3.14, "hello"
    READ I, F, S$
    FORMAT "%, &, $", I, F, S$   # 42, 3.14, hello

  Type conversion happens automatically on READ:
    - Reading a float into an i32 variable truncates it
    - Reading an integer into an f32 variable converts it
    - Reading a string into a string variable copies it to the pool

  RESTORE resets the read pointer to the first DATA item:

    DATA 1, 2, 3
    READ A, B, C
    RESTORE
    READ X              # X = 1 (first item again)

  Negative numbers are supported in DATA:

    DATA -10, -3.14

  DATA statements can appear anywhere in the program. They produce no
  runtime code — values are collected at compile time and stored in the
  WASM data section. Multiple DATA lines are concatenated in order.

  Common use: LED color tables, animation sequences, coordinate lists.

  Example — color table:

    DATA 255, 0, 0,  0, 255, 0,  0, 0, 255
    FOR I = 0 TO 2
      READ R, G, B
      SETLEDCOL(R, G, B)
      WAIT(500)
    END FOR


MID$ Assignment (compiler-only)
-------------------------------

  MID$ can be used on the left side of an assignment to replace characters
  in a string variable in place (QuickBASIC semantics):

    MID$(target$, start, length) = replacement$

  Replaces up to `length` characters in `target$` starting at position
  `start` (1-based) with characters from `replacement$`. The result has
  the same length as the original string — it never grows or shrinks.

  The number of characters actually replaced is the minimum of:
    - `length`
    - LEN(replacement$)
    - remaining characters from `start` to end of `target$`

  Examples:

    A$ = "Hello World"
    MID$(A$, 7, 5) = "Earth"
    FORMAT "$", A$               # Hello Earth

    B$ = "ABCDEF"
    MID$(B$, 3, 2) = "XX"
    FORMAT "$", B$               # ABXXEF

    C$ = "0123456789"
    MID$(C$, 1, 3) = "ABC"
    FORMAT "$", C$               # ABC3456789


Compiled Output
---------------

The compiler produces a valid WASM 1.0 binary with these sections:

  Type       Function signatures
  Import     Host API functions used by the program
  Function   Type indices for local functions (setup + SUBs)
  Memory     1 page (64KB)
  Global     All BASIC variables as mutable globals + heap pointer
  Export     setup function + memory + __line global
  Code       Function bodies as WASM bytecode
  Data       String constants

Only imports that the program actually uses are included — a simple program
that uses GETPARAM and FORMAT will import just those two functions.

Memory layout:

  [0 .. data_end)       String constants
  [data_end .. heap)    Heap for DIM arrays (bump-allocated)
  [0x8000 .. 0xEFFF)   String pool (host-managed, for runtime strings)
  [0xF000 .. 0xF100)   FORMAT argument buffer (scratch space)

Variables are WASM globals (not in linear memory). Arrays are allocated
from the heap in linear memory.

The exported `__line` global (mutable i32) tracks the current BASIC source
line number. The compiler emits a `global.set __line` at the start of each
statement. The WASM runtime reads this on error to report the originating
BASIC line (e.g. "wasm: loop() error: trap (BASIC line 42)"). Hand-written
WASM modules that don't export `__line` are unaffected.


SUB Compilation
---------------

SUBs compile to WASM functions. Parameters become WASM function params.
The compiler saves and restores global values for parameter variables,
matching the BASIC interpreter's shadowing semantics:

  SUB FOO A, B
      LOCAL C
      ...
  END SUB

Compiles to a WASM function that:
  1. Saves current values of globals A and B
  2. Installs parameter values into globals A and B
  3. Executes the body (LOCAL C becomes a WASM local)
  4. Restores globals A and B
  5. Returns i32 (default 0, or RETURN value)


FOR Loop Semantics
------------------

  FOR I = 0 TO N
  FOR I = 0 TO 100 STEP 5
  FOR I = 10 TO 0 STEP -1

The loop variable increments by 1 each iteration (or by the STEP value
if specified). The loop exits when the variable reaches the TO value
(exclusive upper bound — matching the interpreter's behavior).

Without STEP, FOR I = 0 TO 10 runs for I = 0, 1, ..., 9.

With a positive STEP, the loop exits when I >= limit.
With a negative STEP, the loop exits when I <= limit. The direction
check is automatic at runtime based on the sign of the step value.


Limitations
-----------

  - 256 max variables/arrays/subroutines
  - 64 max local functions (SUBs)
  - 8KB string constant table
  - 64KB linear memory (1 WASM page)
  - No nested SUB definitions
  - RESUME is not supported (compile-time error)
  - Array operations (SETARRAY, SHIFTARRAY, ROTATEARRAY, COPYARRAY,
    SCALELIMITARRAY, RGBTOHSVARRAY, HSVTORGBARRAY) are not yet implemented
  - SETLEDRGB is not yet implemented (use per-pixel LED functions instead)
