c2wasm — C to WASM Compiler for ConeZ
======================================

c2wasm is a self-contained C-to-WASM compiler for the ConeZ platform.
It compiles a subset of C directly to WASM 1.0 binaries targeting the
ConeZ wasm3 host API. No external dependencies beyond libc — usable
when clang/LLVM is unavailable, just like bas2wasm.


Building the Compiler
---------------------

  cd tools/c2wasm
  make

Produces the c2wasm binary. Requires only a C compiler (cc/gcc/clang).

The compiler also works as an embedded library in the simulator (no
external c2wasm binary needed). See the Embedded Mode section below.


Usage
-----

  ./c2wasm input.c -o output.wasm
  ./c2wasm input.c                   # output defaults to input.wasm
  ./c2wasm --version                 # show version and build number

The compiler reads a single .c source file and produces a WASM binary
that exports setup(), loop(), memory, and __line — matching the ConeZ runtime's
expected entry points.


Source File Structure
---------------------

A typical c2wasm program:

  #include "conez_api.h"

  static int counter = 0;

  void setup(void) {
      print("hello\n");
  }

  void loop(void) {
      counter++;
      delay_ms(100);
  }

The #include "conez_api.h" directive is special-cased: it registers all
ConeZ API functions as known imports with their C types. No actual file
reading or header parsing is performed.

At least one of setup() or loop() must be defined. Both are exported.

The exported mutable global `__line` is updated before each parsed
statement and can be used by hosts for lightweight profiling/debugging.


Supported C Features
--------------------

Types:
  int           32-bit signed integer (WASM i32)
  float         32-bit float (WASM f32)
  void          no value
  char          8-bit integer (treated as i32)
  double        64-bit float (WASM f64) — full arithmetic and comparison
                support; globals, locals, parameters, return values all work
  long long     64-bit signed integer (WASM i64) — full arithmetic,
                comparisons, bitwise, ++/--, globals, locals, params, returns
                Alternative spellings: long long int
  unsigned int  32-bit unsigned integer (WASM i32) — uses unsigned opcodes
                for division, remainder, comparisons (<, >, <=, >=), and
                right shift. Also: unsigned, unsigned char.
  unsigned long long
                64-bit unsigned integer (WASM i64) — same unsigned opcode
                selection. Also: unsigned long long int.
  uint8_t, uint16_t, uint32_t
                Unsigned i32 (same as unsigned int). sizeof returns 1, 2, 4.
  uint64_t      Unsigned i64 (same as unsigned long long). sizeof returns 8.
  size_t        Unsigned i32 (equivalent to uint32_t on WASM32).
  long          accepted as qualifier (single long = int, with warning)
  short         accepted as qualifier, treated as int (with warning)
  signed        accepted as qualifier, silently ignored (default is signed)
  _Bool / bool  treated as int (i32)
  const         accepted; const int globals (including negative and char
                literals) become compile-time constants; const float/double
                become read-only globals with init values; const locals
                are enforced — assignment, ++, -- on const variables is an error
                Both 'const int' and 'int const' orderings are accepted.
  static        accepted on globals and functions

  Pointers (int *, char *, const char *, void *) are represented as i32.
  Address-of (&), dereference (*), and basic pointer arithmetic are supported
  for expression codegen (see Expressions and Limitations below).

  Type/WASM mapping summary:
    C type              WASM    sizeof
    ------              ----    ------
    void                —       1
    char                i32     1
    int                 i32     4
    unsigned int        i32     4     (unsigned opcodes for / % < > <= >= >>)
    float               f32     4
    double              f64     8
    long long           i64     8
    unsigned long long  i64     8     (unsigned opcodes for / % < > <= >= >>)
    T * (pointer)       i32     4

  Unsigned promotion rules follow the C standard:
  - unsigned int + int → unsigned int
  - unsigned long long + any integer → unsigned long long
  - float/double win over all integer types (signed or unsigned)
  - int-to-unsigned-i64 sign-extends; uint-to-i64 zero-extends

Declarations:
  Global variables with optional initializer:
    static int frame = 0;
    static float brightness = 1.0f;
    int x = 42, y = 0;

  Local variables with optional initializer:
    int i = 0;
    float dist = origin_dist();

  Array declarations and initializers:
    int a[3] = {1, 2, 3};
    int m[2][3];
    int grid[2][3] = {{1, 2, 3}, {4, 5, 6}};
    int d[5] = {[1] = 2, [3] = 4};
    int dm[2][3] = {[1] = {[2] = 9}};
    char name[] = "cone";      // inferred size (includes '\0')
    char tag[3] = "abc";       // exact-size char array (no trailing '\0')

  Notes for char string initializers:
    - char[] = "..." infers size as strlen + 1
    - char[N] = "..." truncates/pads to N bytes per C-style fixed-size array behavior

  Initializer forms at a glance:
    Supported:
      int a[3] = {1, 2, 3};
      int m[2][2] = {{1, 2}, {3, 4}};
      int d[5] = {[1] = 2, [3] = 4};
      int dm[2][3] = {[1] = {[2] = 9}};
      char s[] = "cone";

    Not supported:
      int a[3] = {f(), 2, 3};                 // non-constant global initializer expr
      int a[4] = {[1 + x] = 7};               // non-constant designator index
      struct P p = {.x = 1};                  // structs/designated struct init unsupported

  Global vs local initializer rule:
    - Global initializers must be constant expressions.
    - Local initializers may use runtime expressions.

  Comma-separated declarations (including pointer types):
    int x = 42, y = 0;
    int *a, *b;

  Function definitions with parameters and return types:
    static void helper(int channel, int brightness) { ... }
    static int clamp(int val, int lo, int hi) { ... }

  Unnamed function parameters (counted but not referenceable):
    void callback(int, int, int code) { print_i32(code); }

  Forward declarations (must have matching definition with same params):
    static void helper(int channel, int brightness);

Control Flow:
  if (cond) stmt
  if (cond) stmt else stmt
  while (cond) stmt
  do stmt while (cond);
  for (init; cond; incr) stmt
  switch (expr) { case N: ... break; default: ... break; }
  Case labels support constant expressions: case BASE + 2:, case (A | B):
  break
  continue
  return expr;
  return;
  { compound statements }

  For-loop init declarations are supported: for (int i = 0; ...).
  Switch/case supports C-standard fall-through — cases without break
  fall through to the next case body. The default label can appear
  anywhere in the switch body (not just last).

Expressions (full C operator precedence):
  Arithmetic:    +  -  *  /  %
  Comparison:    ==  !=  <  >  <=  >=
  Logical:       &&  ||  !          (short-circuit evaluation)
  Bitwise:       &  |  ^  ~  <<  >>
  Assignment:    =  +=  -=  *=  /=  %=  &=  |=  ^=  <<=  >>=
  Increment:     ++var  --var  var++  var--
  Ternary:       cond ? then : else
  Comma:         expr1, expr2  (evaluates both, result is last)
  Cast:          (int)expr  (float)expr  (double)expr  (void)expr
  sizeof:        sizeof(int)  sizeof(float)  sizeof(double)  sizeof(void)
                 sizeof(void*)  sizeof(int*)  etc.
                 sizeof(expr) — returns type size without evaluating expr
                 sizeof(void) returns 1 (GCC extension)

  Pointer-related expression support:
    &var          Address-of for local scalars/arrays and array lvalues
    &arr[i]       Address-of subscripted lvalues (including local arrays)
    &x            Address-of local scalar (via compiler-managed spill slot)
    *ptr          Dereference load/store path
    arr[i]        Subscript read/write path
    arr[i][j]     Chained subscript read/write for multidimensional arrays
    ptr + n       Pointer advance by n * element_size
    n + ptr       Commutative pointer advance
    ptr - n       Pointer retreat by n * element_size
    ptr1 - ptr2   Element-distance difference (scaled subtraction)

  Operator precedence follows the C standard (15 levels).
  Mixed int/float expressions promote to float automatically.
  Mixed int/double or float/double expressions promote to double.
  Bitwise operators coerce operands to int.
  Compound bitwise assignments (&= |= ^= <<= >>=) coerce float/double
  operands to int before the operation.
  Float %= uses fmodf import (not integer remainder).
  Double %= uses fmod import (not integer remainder).
  Double % uses fmod import directly.

Literals:
  Integer:       42, 0xFF, 0x1A, 0755, -1
                 Suffixes: U/u, L/l, LL/ll (combined ULL/ull forms supported)
                 Invalid integer suffixes are rejected
                 Invalid octal literals (e.g. 08, 09) are rejected
                 Invalid hex literals (e.g. 0x with no digits) are rejected
                 Type selection follows C-style fit rules in the compiler's
                 data model (int/long are 32-bit, long long is 64-bit):
                 - Decimal unsuffixed: int -> long long -> unsigned long long
                 - Hex/octal unsuffixed: int -> unsigned int -> long long -> unsigned long long
                 - With U: unsigned int -> unsigned long long
                 - With L (long=32-bit here): 32-bit first, then 64-bit as needed
  Float (f32):   3.14f, 0.5f (f/F suffix required for float)
  Double (f64):  1.0, .5, 5. (unsuffixed decimal = double, per C standard)
                 Invalid float suffixes are rejected
                 Invalid exponents (e.g. 1e+, 1e-) are rejected
                 Adjacent-dot malformed forms (e.g. 1..2) are rejected
  Character:     'A', '\n', '\t', '\\', '\0', '\x41', '\101', '\a', '\b', '\f', '\v', '\?'
                 Empty ('' ) and multi-character ('ab') literals are rejected
                 Invalid hex escapes (e.g. '\x') are rejected
  String:        "hello\n", "multi" "part" (concatenation)
                 Supports the same escape forms as character literals
                 Invalid hex escapes (e.g. "\x") are rejected

Preprocessor:
  #include "conez_api.h"      Register all ConeZ API imports
  #include <stdint.h>         Silently ignored (standard headers)
  #define NAME value          Simple text macros (no function-like macros)
  #define LONG value \        Backslash line continuation in #define
          continuation
  #undef NAME                 Remove a previously defined macro
  #ifdef NAME ... #endif      Conditional compilation
  #ifndef NAME ... #endif     Conditional compilation
  #else                       Else branch for #ifdef/#ifndef/#if
  #elif                       Else-if chains: #if A / #elif B / #else / #endif
  #error message              Abort compilation with error message
  #warning message            Emit warning and continue compilation

  Common predefined macros:
  __LINE__, __FILE__, __DATE__, __TIME__, __COUNTER__,
  __STDC__, __STDC_VERSION__, __STDC_HOSTED__

  #if supports full constant expression evaluation:
  #if 0 ... #endif            Block comment via preprocessor
  #if N ... #endif            Any integer (0 = skip, nonzero = keep)
  #if MACRO_NAME              Macro expanded to integer; undefined = 0
  #if defined(NAME)           Test whether a macro is defined
  #if !defined(NAME)          Test whether a macro is NOT defined
  #if defined NAME            Also works without parentheses
  #if A > B                   Comparison: <  >  <=  >=  ==  !=
  #if A && B                  Logical:    &&  ||  !
  #if A + B == C              Arithmetic: +  -  *  /  %
  #if A & B                   Bitwise:    &  |  ^  ~  <<  >>
  #if (A + 1) * 2             Parenthesized subexpressions
  #if 'A'                     Character literals
  #if VERSION > 2 && defined(FEATURE)
                              Complex expressions combining all of the above

  The #if evaluator uses 64-bit integer arithmetic internally with
  signed/unsigned-aware comparisons and division/modulo behavior.
  Object-like macro values used in #if may be literals, identifiers,
  or simple constant expressions; recursive macro cycles are bounded.
  Signed macro values (e.g. #define NEG -1) are handled correctly.
  Macros that start with a literal but include operators (e.g. 1ULL<<63)
  are evaluated as full expressions in #if.
  Trailing garbage in #if expressions is rejected.
  Missing ')' in parenthesized #if expressions or defined(...) is rejected.
  Missing unary/binary operands in #if expressions are rejected.
  Empty #if expressions are rejected.

Comments:
  // line comments
  /* block comments */


Builtins
--------

printf(fmt, args...):
  Compiles to host_printf(fmt_ptr, args_ptr). The format string is stored
  in the data section. Arguments are saved to temporary WASM locals, then
  stored sequentially at memory address 0xF000. Float arguments are
  promoted to double per C's default argument promotion rules.

  Supported format specifiers: %d %i %u %x %X %c %s %f %p %%
  With width, precision, flags (as handled by the host's snprintf).

  Example:
    printf("dist: %.1f m\n", (double)dist);

print(str):
  Shorthand for print_str(ptr, len). Only accepts string literals:
    print("hello world\n");

WASM-native math (single opcode, no import):
  These functions compile directly to WASM opcodes with zero overhead.
  No host import is needed — the WASM engine executes them natively.

  Float (f32):   sqrtf, fabsf, floorf, ceilf, truncf, fminf, fmaxf
  Double (f64):  sqrt, fabs, floor, ceil, trunc, fmin, fmax

Host-imported math (transcendentals via libm):
  Float (f32):   sinf, cosf, tanf, asinf, acosf, atanf, atan2f,
                 powf, expf, logf, log2f, fmodf
  Double (f64):  sin, cos, tan, asin, acos, atan, atan2,
                 pow, exp, log, log2, fmod

Host-imported curve/interpolation:
  float lerp(float a, float b, float t)
  int   larp(int x_pos, int x_min, int x_max, int min_val, int max_val,
             int offset, int window, int stride)
  float larpf(float x_pos, float x_min, float x_max, float min_val,
              float max_val, float offset, float window, int stride)

  Example:
    float r = sqrtf(x*x + y*y);
    float a = fabsf(value);


ConeZ API Functions
-------------------

All functions declared in tools/wasm/conez_api.h are available after
#include "conez_api.h". These include:

  LED:        led_set_pixel, led_fill, led_show, led_count,
              led_set_pixel_hsv, led_fill_hsv, led_gamma8, led_set_gamma,
              led_set_buffer, led_shift, led_rotate, led_reverse,
              hsv_to_rgb, rgb_to_hsv

  GPIO:       pin_set, pin_clear, pin_read, analog_read

  GPS:        get_lat, get_lon, get_alt, get_speed, get_dir,
              gps_valid, gps_present, has_origin, origin_dist,
              origin_bearing, get_origin_lat, get_origin_lon

  IMU:        get_roll, get_pitch, get_yaw, get_acc_x/y/z,
              imu_valid, imu_present

  Sensors:    get_temp, get_humidity, get_brightness,
              get_bat_voltage, get_solar_voltage,
              get_battery_percentage, get_battery_runtime

  Sun:        get_sunrise, get_sunset, sun_valid, is_daylight,
              get_sun_azimuth, get_sun_elevation

  Time:       millis, delay_ms, time_valid, get_second, get_minute,
              get_hour, get_day, get_month, get_year,
              get_day_of_week, get_day_of_year, get_is_leap_year,
              get_epoch_ms, get_uptime_ms, get_last_comm_ms

  Params:     get_param, set_param, should_stop, random_int

  Sync:       wait_pps, wait_param, cue_playing, cue_elapsed

  Output:     print_i32, print_f32, print_i64, print_f64, print_str

  Math f32:   sinf, cosf, tanf, asinf, acosf, atanf, atan2f,
              powf, expf, logf, log2f, fmodf
  Math f64:   sin, cos, tan, asin, acos, atan, atan2,
              pow, exp, log, log2, fmod
  Curve:      lerp, larp, larpf

  File I/O:   file_open, file_close, file_read, file_write,
              file_size, file_seek, file_tell,
              file_exists, file_delete, file_rename,
              file_mkdir, file_rmdir

  Compress:   inflate_file, inflate_file_to_mem, inflate_mem,
              deflate_file, deflate_mem_to_file, deflate_mem

  LUT:        lut_load, lut_save, lut_check, lut_get, lut_set, lut_size

  Format:     host_snprintf (low-level snprintf to WASM memory)

See documentation/wasm-api.txt for full API documentation.


NOT Supported
-------------

The following C features are NOT in scope:

  - struct, union, enum, typedef
  - Full C array semantics (see limitations below; basic arrays work)
  - Full pointer semantics (see limitations below; basic pointer ops work)
  - malloc/free (dynamic memory allocation)
  - goto, labels
  - Function pointers
  - Multi-file compilation (#include of user headers)
  - Variadic functions (except printf builtin)
  - Bitfields
  - String operations at runtime (strlen, strcmp, etc.)

For programs requiring these features, use clang --target=wasm32 instead.

Current Array/Pointer Limitations
---------------------------------

  Supported:
  - Global and local array initializers with constant brace lists, including
    multidimensional nested braces in row-major order. Designated initializers
    like [i] = value are supported. Negated macros (-MACRO) work in initializers.
    Out-of-bounds initializer indices are detected and reported as errors.

  - char[] / char[N] string-literal initialization. Inferred-size arrays are
    currently limited to char[] with string literal initializers.

  - Array element assignment (arr[i] = x) and read (x = arr[i]), including
    multidimensional chained subscripts (arr[i][j]).

  - Compound assignment on array elements: arr[i] += / -= / *= / /= / %= /
    &= / |= / ^= / <<= / >>= all work, including mixed-type coercion and
    correct signed/unsigned opcode selection.

  - Pointer dereference assignment (*p = x) and read (x = *p).

  - Compound assignment through pointer dereference (*p += x, etc.).

  - Pointer increment/decrement (++p, p++, --p, p--) correctly scales by
    the element size (sizeof(*p)), not by 1.

  - Taking address of local scalar variables via compiler-managed
    linear-memory spill slots. Practical for single-threaded scripts,
    but does not model a full C stack-frame address model.

  - Pointer arithmetic: ptr + n, n + ptr, ptr - n, ptr1 - ptr2 (all scaled
    by element size).

  Not supported:
  - Non-constant global initializer expressions (e.g. int a[3] = {f(), 2, 3})
  - Taking address of non-array global WASM globals (those values are not
    linear-memory lvalues)
  - Full C pointer type system with complete alias/qualifier rules
  - Pointer comparison (<, >, ==, etc.)
  - Array parameters (arrays cannot be passed to/from functions by pointer)


Memory Layout
-------------

  0x0000 - data_len      Data section (global arrays → local arrays → string literals)
  data_len - heap_start  Padding (4-byte aligned)
  heap_start - 0x8000    Low heap (user malloc/calloc, grows upward from _heap_ptr)
  0x8000 - 0xEFFF        String pool (host-managed, for runtime string ops)
  0xF000 - 0xF0FF        Printf argument buffer (256 bytes)

  WASM globals:
    global[0]   _heap_ptr    Low heap pointer (initialized to heap_start, exported)
    global[1]   __line       Current source line (exported)
    global[2+]  User globals (static int, static float, etc.)

Static arrays (global and local) are compiled directly into the data
section starting at offset 0. This naturally places hot data in the
DRAM window (first 4KB) on PSRAM-backed systems. Dynamic allocations
via malloc()/calloc() use the low heap starting at _heap_ptr, falling
back to the string pool at 0x8000 if the low heap is full.

Scalar variables (int, float, etc.) are WASM globals, not in linear
memory — they generate zero memory traffic.


Compiler Architecture
---------------------

Source files in tools/c2wasm/:

  c2wasm.h      Shared header: WASM opcodes, C type system, symbol table,
                emit helpers, token definitions
  main.c        Driver: global state, argument parsing, top-level compile
  lexer.c       C tokenizer: identifiers, keywords, literals, operators,
                comments, macro expansion
  preproc.c     Preprocessor: #include special-case, #define/#undef (with
                line continuation), #ifdef/#ifndef/#elif/#else/#endif,
                #error/#warning, full #if constant expression evaluator,
                API registration
  type.c        Type parsing (void/int/float/double/char/long long/unsigned int/
                unsigned long long/uint8_t..uint64_t/size_t/short/signed/
                _Bool/bool/static/const) and pointer star consumption
  expr.c        Precedence-climbing expression parser (15 levels),
                short-circuit &&/||, casts, ternary, comma, printf/print builtins
  stmt.c        Statement parser: functions, if/else, for, while, do/while,
                switch/case (with constant expression evaluator for case
                labels), break/continue/return, local/global declarations
  assemble.c    WASM binary assembly: type/import/function/memory/global/
                export/code/data sections, import index remapping
  buf.c         Byte buffer primitives (from bas2wasm, with f64/i64 additions)
  imports.c     ConeZ API import definition table (from bas2wasm)

The compiler makes a single pass over the source, emitting WASM bytecode
directly into per-function buffers. Import call targets are recorded as
fixups and remapped during assembly to account for import compaction
(only used imports are included in the output).


Examples
--------

All three examples in tools/wasm/examples/ compile with c2wasm:

  cd tools/c2wasm
  ./c2wasm ../wasm/examples/rgb_cycle.c -o rgb_cycle.wasm
  ./c2wasm ../wasm/examples/hsv_rainbow.c -o hsv_rainbow.wasm
  ./c2wasm ../wasm/examples/sos_flash.c -o sos_flash.wasm

Output sizes (unstripped):
  rgb_cycle.wasm       341 bytes   (5 imports, 2 functions)
  hsv_rainbow.wasm     316 bytes   (5 imports, 2 functions)
  sos_flash.wasm       633 bytes   (9 imports, 3 functions)


Testing
-------

The test suite is in tools/c2wasm/test/. Run with:

  cd tools/c2wasm
  make test

Tests compile each .c file to .wasm and validate with wasm-validate.
Reject tests (reject_*.c) verify that the compiler correctly reports
errors. The three examples in tools/wasm/examples/ are also compiled.

Test files cover: basic types, arithmetic, bitwise ops, comparisons,
control flow (if/while/do/for/switch/break/continue), assignment ops,
user functions (forward decls, recursion), casts and sizeof, ternary
operator, literals (int/float/char/string/hex/octal), printf formats,
preprocessor (#define/#ifdef/#if 0/#if N/#undef/#if defined/#if expr/
#elif/#elif chains/nested #elif/#error), scoping (block/for-init/shadow),
math imports, trig imports, API calls, file I/O, WASM-native builtins
(sqrtf/fabsf/floorf/ceilf/truncf/fminf/fmaxf and f64 equivalents),
comments, setup-only and loop-only programs, recursive and mutual macro
guards, nested #ifdef (including nested #else inside #if 0), sizeof
without evaluation, implicit returns, ternary and for-loop increment
with function calls (call fixup adjustment), string concatenation,
double (f64) arithmetic/comparisons/globals/casts, for-loop with calls
in both body and increment, const negative/char initializers, float %=
and bitwise compound ops, switch fall-through and default-anywhere,
comma operator, typed ternary (float/double/long long branches), double
pre/post increment/decrement, double %/%= via fmod, f64 math imports
(sin/cos/tan/etc.), sizeof(type*) for pointer types, sizeof(long long),
#if preprocessor negation and full expressions, pointer comma-separated
declarations (int *a, *b;), pointer arithmetic smoke tests, bare return
in non-void functions, double literals (f/F suffix vs unsuffixed),
long long (i64) arithmetic/API/global init/ternary/printf, 'long long int'
and 'unsigned long long int' type parsing, 'int const' trailing qualifier,
'long' bare warning, case labels with constant expressions, const globals
(int/float/double), short/signed/_Bool/bool type keywords, const local
enforcement, #define line continuation, #if macro name expansion and
comparison expressions, unnamed function parameters, forward declaration
param matching, switch warning for statements before first case, unsigned
integer operations (uint32_t/uint64_t comparison, division, remainder,
right shift, mixed signed/unsigned promotion, compound assignment,
conversions), curve helper import registration tests (lerp/larp/larpf).

Array/pointer tests: array element assignment (arr[i] = x stores value not
address), pointer dereference assignment (*p = x), assignment in if/else
(stack balance), compound assignment on array elements (+=, -=, *=, /=,
&=, |=, ^=, <<=), compound assignment through pointer dereference (*p +=),
pointer increment/decrement scaling by element size (++p, p++, --p, p--),
negated macros in array initializers (-MACRO), array initializer bounds
checking, multidimensional array indexing and nested initializer tests,
designated array initializer tests, address-of local/global scalar plus
array lvalue tests, global/local array initializer tests, global
float/double/long long address-of tests, and compound ops through global
pointer aliases, and malloc/free/calloc/realloc import tests.

Preprocessor tests: #if unsigned literal classification (1U, 100UL),
#if unsigned 64-bit literal comparison, #if macro identifier/expression
expansion (with recursion guard behavior), #if negative macro comparison,
#if macro-literal-with-operator (e.g. 1ULL<<63, -1ULL), integer-literal
width/signedness for large decimal/hex and U/L/LL suffix combinations,
predefined macros (__LINE__/__FILE__/__DATE__/__TIME__/__COUNTER__/__STDC*).

Rejection tests: undefined variables/functions/forward declarations,
unterminated block comments, void expression as operand, void/non-void
ternary mismatch, const variable assignment, forward declaration param
mismatch, #error directive, invalid octal/hex literals (both lexer and
#if), malformed float exponents, malformed hex-escapes (char/string
literals and #if), empty/multi-character char literals, invalid integer
suffix (including f/F suffix on plain integers), invalid float suffixes,
adjacent-dot malformed floats, trailing-garbage #if expressions,
parenthesis-mismatch in #if, missing operands (unary/binary) in #if,
empty #if expressions.

Adding a test: create a .c file in test/. Positive tests must compile
to valid WASM. Files named reject_*.c must fail compilation.


Embedded Mode
-------------

c2wasm can be compiled as a library for embedding in the Qt simulator.
This is controlled by the C2WASM_EMBEDDED preprocessor define.

Platform abstraction (c2wasm_platform.h):

  In standalone mode (default), cw_malloc/cw_error/cw_fatal are
  #defined to malloc/fprintf/exit — zero overhead.

  In embedded mode, they become real functions that redirect to
  host-provided callbacks. Fatal errors use longjmp(cw_bail) instead
  of exit(1). Diagnostic messages are routed through cw_on_error
  and cw_on_info function pointer callbacks.

Library API:

  Buf c2wasm_compile_buffer(const char *src, int len, const char *filename);
      Compile C source to WASM. filename is used in error messages.
      Returns a Buf with the .wasm binary (len == 0 on error). Caller
      must call buf_free() on the result and c2wasm_reset() after
      each compilation.

  void c2wasm_reset(void);
      Reset all compiler state for reuse. Must be called between
      compilations.

Single-TU embedding:

  The simulator includes all c2wasm .c files into a single compilation
  unit (c2wasm_embed.c) via #include. This keeps static variables and
  functions internal. The wrapper defines C2WASM_EMBEDDED before
  including the sources.

Symbol prefixing:

  In embedded mode, shared global names (source, had_error, func_bufs,
  expr, assemble_to_buf, etc.) are macro-prefixed to cw_source,
  cw_had_error, etc. This avoids link-time collisions when both
  c2wasm and bas2wasm are linked into the same binary.

Simulator usage:

  The simulator links c2wasm as a static library (c2wasm-embed in
  CMakeLists.txt). CompilerWorker calls c2wasm_compile_buffer()
  directly — no subprocess spawning.

Firmware embedding:

  c2wasm is embedded in firmware via firmware/src/wasm/c2wasm_embed.c
  (single-TU pattern, same as bas2wasm). Guarded by INCLUDE_C_COMPILER
  build flag in platformio.ini (enabled by default).

  To fit in DRAM, embedded mode shrinks the Symbol struct (name[32]
  instead of name[64], heap-allocated macro_val instead of char[128])
  and dynamically allocates large arrays (syms, func_bufs, ctrl_stk,
  data_buf) only during compilation. Transient heap cost: ~63KB.

  The compile CLI command compiles .c files on-device:

    compile /demo.c               compile to /demo.wasm
    compile /demo.c run           compile and auto-run


Comparison with clang
---------------------

  Feature              c2wasm              clang
  -------              ------              -----
  Dependencies         libc only           LLVM/clang toolchain
  Build time           <1ms per file       ~100ms per file
  Optimization         None (direct emit)  -O2 (dead code, inlining, etc.)
  Output size          Slightly larger     Smaller (optimized)
  C coverage           Subset (see above)  Full C11/C17
  bulk-memory          Not used            -mbulk-memory for memcpy/memset
  Debug info           None                Optional (-g)
  Portability          Any C compiler      Requires LLVM target support

For simple LED/sensor programs, c2wasm produces functionally identical
output. For programs requiring structs, full pointer semantics, or
advanced optimization, use clang.
